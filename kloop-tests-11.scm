
(begin-tests "destructuring"

(test-equal '((4.0 2 1) (8.3 6 5) (10.4 9 8))
	    (loop for (a b c) of-type (integer integer float) in
		  '((1 2 4.0) (5 6 8.3) (8 9 10.4))
		  collect (list c b a)))

(test-equal '((4.0 2.0 1.0) (8.3 6.0 5.0) (10.4 9.0 8.0))
	    (loop for (a b c) of-type float in
		  '((1.0 2.0 4.0) (5.0 6.0 8.3) (8.0 9.0 10.4))
		  collect (list c b a)))

(test-equal '(1.0 2.0 3 4 #f #f)
	    (loop with (a b) of-type float = '(1.0 2.0)
		  and (c d) of-type integer = '(3 4)
		  and (e f)
		  return (list a b c d e f)))
(test-equal '((6 7 8) (3 4 5) (0 1 2))
	    (let ((s '()))
	      (loop for (a (b) ((c))) in '((0 (1) ((2))) (3 (4) ((5))) (6 (7) ((8))))
		    do (push (list a b c) s))
	      s))

(test-equal '((6 8) (3 5) (0 2))
	    (let ((s '()))
	      (loop for (a nil ((b))) in '((0 (1) ((2))) (3 (4) ((5))) (6 (7) ((8))))
		    do (push (list a b) s))
	      s))

(test-equal '((6 8) (3 5) (0 2))
	    (let ((s '()))
	      (loop for (a nil ((((b))))) in
		    '((0 (1) ((((2))))) (3 (4) ((((5))))) (6 (7) ((((8))))))
		    do (push (list a b) s))
	      s))

(test-equal '((2 . 3) (0 . 1))
	    (let ((s '()))
	      (loop for (a . b) in '((0 . 1) (2 . 3)) do (push (cons a b) s))
	      s))

(test-equal '((2 3) (0 1))
	    (let ((s '()))
	      (loop for (a . (b)) in '((0 1) (2 3)) do (push (list a b) s))
	      s))
(test-equal '(3 2 1 0)
	    (let ((s '()))
	      (loop for (a) on '(0 1 2 3) do (push a s)) s))
(test-equal '((4 ()) (3 (4)) (2 (3 4)) (1 (2 3 4)) (0 (1 2 3 4)))
	    (let ((s '()))
	      (loop for (a . b) on '(0 1 2 3 4) do (push (list a b) s))
	      s))
(test-equal '((4 5) (2 3) (0 1))
	    (let ((s '())) (loop for (a b) across '#((0 1) (2 3) (4 5))
				 do (push (list a b) s))
		 s))
(test-equal '((4 5) (2 3) (0 1))
	    (let ((s '())) (loop for (a ((b))) 
				 across '#((0 ((1))) (2 ((3))) (4 ((5))))
				 do (push (list a b) s))
		 s))
(test-equal '(0 1) (loop with (a b) = '(0 1) return (list a b)))
(test-equal '(0 #f #f) (loop with (a b c) = '(0) return (list a b c)))
(test-equal 2 (loop with (#f #f x) = '(0 1 2) return x))
(test-equal '((0 #f #f) (1 #f #f) (2 #f #f))
	    (loop for (a b c) in '((0) (1) (2))
		  collect (list a b c)))
(test-equal '((0 2) (1 3) (2 4))
	    (loop for (a #f b) in '((0 1 2) (1 2 3) (2 3 4))
		  collect (list a b)))

(test-equal '((0 . x) (1 . y) (2 . z))
	    (loop for (a . b) t in '((0 . x) (1 . y) (2 . z)) collecting (cons a b)))
(test-equal '((0 . x) (1 . y) (2 . z))
	    (loop for (a . b) of-type t in '((0 . x) (1 . y) (2 . z))
		  collecting (cons a b)))
(test-equal '((0 . x) (1 . y) (2 . z))
	    (loop for (a . b) of-type (fixnum . symbol) in '((0 . x) (1 . y) (2 . z))
		  collecting (cons a b)))
(test-equal '((0 . x) (1 . y) (2 . z))
	    (loop for (a ((b))) of-type (fixnum ((symbol))) in
		  '((0 ((x))) (1 ((y))) (2 ((z))))
		  collecting (cons a b)))
(test-equal '((0 . x) (1 . y) (2 . z))
	    (loop for (a ((b))) of-type (fixnum symbol) in
		  '((0 ((x))) (1 ((y))) (2 ((z))))
		  collecting (cons a b)))
(test-equal '((0 . 10) (1 . 11) (2 . 12))
	    (loop for (a ((b))) fixnum in '((0 ((10))) (1 ((11))) (2 ((12))))
		  collecting (cons a b)))
(test-equal '((0 10 20 30) (1 11 21 31) (2 12 22 32))
	    (loop for (a ((b)) c (((d)))) fixnum in
		  '((0 ((10)) 20 (((30))))
		    (1 ((11)) 21 (((31))))
		    (2 ((12)) 22 (((32)))))
		  collecting (list a b c d)))
(test-equal '((0 10 20 30) (1 11 21 31) (2 12 22 32))
	    (loop for (a ((b)) c (((d))))
		  of-type (fixnum ((fixnum)) fixnum (((fixnum)))) in
		  '((0 ((10)) 20 (((30))))
		    (1 ((11)) 21 (((31))))
		    (2 ((12)) 22 (((32)))))
		  collecting (list a b c d)))
(test-equal '((0 30) (1 31) (2 32))
	    (loop for (a #f #f (((b)))) 
		  of-type (fixnum nil nil (((fixnum)))) in
		  '((0 ((10)) 20 (((30))))
		    (1 ((11)) 21 (((31))))
		    (2 ((12)) 22 (((32)))))
		  collecting (list a b)))

(test-equal '(0 1 2) (loop for (a) fixnum on '(0 1 2) collecting a))
(test-equal '(0 1 2) (loop for (a) of-type fixnum on '(0 1 2) collecting a))
(test-equal '(0.3 1.3 2.3) (loop for (a) float on '(0.3 1.3 2.3) collecting a))
(test-equal '(0.3 1.3 2.3)
	    (loop for (a) of-type float on '(0.3 1.3 2.3) collecting a))
(test-equal '(0 1 2) (loop for (a) t on '(0 1 2) collecting a))
(test-equal '(0 1 2) (loop for (a) of-type t on '(0 1 2) collecting a))
(test-equal '(0 1.0 2/3) (loop for (a) of-type real on '(0 1.0 2/3) collecting a))
(test-equal '((0 2) (1 #f) (2 #f))
	    (loop for (a nil b) fixnum on '(0 1 2) collecting (list a b)))
(test-equal '((0 2) (1 #f) (2 #f))
	    (loop for (a nil b) of-type (fixnum nil fixnum) on '(0 1 2)
		  collecting (list a b)))
(test-equal '(1 2 3 2 3 3)
	    (loop for (nil . tail) t on '(0 1 2 3) append tail))
(test-equal '(1 2 3 2 3 3)
	    (loop for (nil . tail) of-type t on '(0 1 2 3) append tail))
(test-equal '(1 2 3 2 3 3)
	    (loop for (nil . tail) of-type list on '(0 1 2 3) append tail))

(test-equal '((0 x) (1 y) (2 z))
	    (loop for (a b) t across '#((x 0) (y 1) (z 2)) 
		  collecting (list b a)))
(test-equal '((0 x) (1 y) (2 z))
	    (loop for (a b) of-type t across '#((x 0) (y 1) (z 2))
		  collecting (list b a)))
(test-equal '((0 x) (1 y) (2 z))
	    (loop for (a b) of-type ((member x y z) (member 0 1 2))
		  across '#((x 0) (y 1) (z 2))
		  collecting (list b a)))


(test-equal #t (loop for (a) t = '(0) then (list (+ 1  a))
		     when (= a 3) return #t))
(test-equal #t (loop for (a) of-type t = '(0) then (list (+ 1  a))
	    when (= a 3) return #t))
(test-equal #t (loop for (a) of-type (t) = '(0) then (list (+ 1  a))
	    when (= a 3) return #t))
(test-equal #t (loop for (a) fixnum = '(0) then (list (+ 1  a))
	    when (= a 3) return #t))
(test-equal #t (loop for (a) of-type fixnum = '(0) then (list (+ 1  a))
	    when (= a 3) return #t))
(test-equal #t (loop for (a) of-type (fixnum) = '(0) then (list (+ 1  a))
	    when (= a 3) return #t))
(test-equal #t (loop for (a) float = '(0.0) then (list (+ 1  a))
	    when (= a 3.0) return #t))
(test-equal #t (loop for (a) of-type float = '(0.0) then (list (+ 1  a))
	    when (= a 3.0) return #t))
(test-equal #t (loop for (a) of-type (float) = '(0.0) then (list (+ 1  a))
	    when (= a 3.0) return #t))
(test-equal '((0 1) (2 3) (4 5))
	    (loop for (a b) t = '(0 1) then (list (+ 1  b) (+ b 2))
		  when (> a 5) do (loop-finish)
		  collect (list a b)))
(test-equal '((0 1) (2 3) (4 5))
	    (loop for (a b) of-type t = '(0 1) then (list (+ 1  b) (+ b 2))
		  when (> a 5) do (loop-finish)
		  collect (list a b)))
(test-equal '((0 1) (2 3) (4 5))
	    (loop for (a b) of-type (t t) = '(0 1) then (list (+ 1  b) (+ b 2))
		  when (> a 5) do (loop-finish)
		  collect (list a b)))
(test-equal '((0 1) (2 3) (4 5))
	    (loop for (a b) fixnum = '(0 1) then (list (+ 1  b) (+ b 2))
		  when (> a 5) do (loop-finish)
		  collect (list a b)))
(test-equal '((0 1) (2 3) (4 5))
	    (loop for (a b) of-type fixnum = '(0 1) then (list (+ 1  b) (+ b 2))
		  when (> a 5) do (loop-finish)
		  collect (list a b)))
(test-equal '((0 1) (2 3) (4 5))
	    (loop for (a b) of-type (fixnum fixnum) = '(0 1)
		  then (list (+ 1  b) (+ b 2))
		  when (> a 5) do (loop-finish)
		  collect (list a b)))
(test-equal '((0.0 1.0) (2.0 3.0) (4.0 5.0))
	    (loop for (a b) float = '(0.0 1.0) then (list (+ 1  b) (+ b 2.0))
		  when (> a 5) do (loop-finish)
		  collect (list a b)))
(test-equal '((0.0 1.0) (2.0 3.0) (4.0 5.0))
	    (loop for (a b) of-type float = '(0.0 1.0) then (list (+ 1  b) (+ b 2.0))
		  when (> a 5) do (loop-finish)
		  collect (list a b)))
(test-equal '((0.0 1.0) (2.0 3.0) (4.0 5.0))
	    (loop for (a b) of-type (float float) = '(0.0 1.0)
		  then (list (+ 1  b) (+ b 2.0))
		  when (> a 5) do (loop-finish)
		  collect (list a b)))
(test-equal '((0 1.0) (2 3.0) (4 5.0))
	    (loop for (a b) of-type (fixnum float) = '(0 1.0)
		  then (list (+ a 2) (+ b 2.0))
		  when (> a 5) do (loop-finish)
		  collect (list a b)))



(test-equal 
 "hash-table + destructuring (requires equal-hash 4)"
 '()
 
 (let ((table (make-hash-table :test 'equal))
       (s '()))
   (mapc (lambda (k v) (setf (gethash k table) v))
	 '((k0 0) (k1 1) (k2 2)) '(v0 v1 v2))
   (loop for (k kn) t being each hash-key of table do (push (list k kn) s))
   (set-exclusive-or s '((k0 0) (k1 1) (k2 2)) :test equal)))
(test-equal
 "hash-table + destructuring (requires equal-hash 5)"
 '()
 (let ((table (make-hash-table :test 'equal))
       (s '()))
   (mapc (lambda (k v) (setf (gethash k table) v))
	 '((k0 0) (k1 1) (k2 2)) '(v0 v1 v2))
   (loop for (k kn) of-type t being each hash-key of table
	 do (push (list k kn) s))
   (set-exclusive-or s '((k0 0) (k1 1) (k2 2)) :test equal)))
(test-equal 
 "hash-table + destructuring (requires equal-hash 6)"
 '()
 (let ((table (make-hash-table :test 'equal))
       (s '()))
   (mapc (lambda (k v) (setf (gethash k table) v))
	 '((k0 0) (k1 1) (k2 2)) '(v0 v1 v2))
   (loop for (k kn) of-type (symbol fixnum) being each hash-key of table
	 do (push (list k kn) s))
   (set-exclusive-or s '((k0 0) (k1 1) (k2 2)) :test equal)))
(test-equal
 "hash-table + destructuring (requires equal-hash 7)"
 '()
 (let ((table (make-hash-table :test 'equal))
       (s '()))
   (mapc (lambda (k v) (setf (gethash k table) v))
	 '((k0 0) (k1 1) (k2 2)) '(v0 v1 v2))
   (loop for (k kn) of-type t being each hash-key of table
	 do (push (list k kn) s))
   (set-exclusive-or s '((k0 0) (k1 1) (k2 2)) :test equal)))
(test-equal
 "hash-table + destructuring (requires equal-hash 8)"
 '()
 (let ((table (make-hash-table :test 'equal))
       (s '()))
   (mapc (lambda (k v) (setf (gethash k table) v))
	 '((k0 0) (k1 1) (k2 2)) '(v0 v1 v2))
   (loop for (k kn) of-type (t t) being each hash-key of table
	 do (push (list k kn) s))
   (set-exclusive-or s '((k0 0) (k1 1) (k2 2)) :test equal)))

)
